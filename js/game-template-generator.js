/**
 * Game Template Generator
 * Automatically generates Phaser.js game files for course milestone levels
 */

class GameTemplateGenerator {
    constructor() {
        this.baseGameTemplate = `/**
 * {GAME_NAME} - Interactive Learning Game
 * Generated by AI Course Generator
 */

class {CLASS_NAME} extends Phaser.Scene {
    constructor() {
        super('{SCENE_KEY}');
        this.score = 0;
        this.gameState = 'playing';
    }

    preload() {
        // Load assets here
        console.log('Loading {GAME_NAME}...');
    }

    create() {
        // Set up game background
        this.cameras.main.setBackgroundColor('#1a1a2e');
        
        // Title
        this.add.text(400, 50, '{GAME_TITLE}', {
            fontSize: '32px',
            fontFamily: 'Arial',
            color: '#ffffff',
            fontStyle: 'bold'
        }).setOrigin(0.5);
        
        // Instructions
        this.add.text(400, 100, '{INSTRUCTIONS}', {
            fontSize: '16px',
            fontFamily: 'Arial',
            color: '#cccccc',
            align: 'center',
            wordWrap: { width: 700 }
        }).setOrigin(0.5);
        
        // Score display
        this.scoreText = this.add.text(50, 30, 'Score: 0', {
            fontSize: '24px',
            fontFamily: 'Arial',
            color: '#00ff00'
        });
        
        // Timer
        this.timeLeft = 60;
        this.timerText = this.add.text(750, 30, 'Time: 60s', {
            fontSize: '24px',
            fontFamily: 'Arial',
            color: '#ffaa00'
        }).setOrigin(1, 0);
        
        // Start timer
        this.time.addEvent({
            delay: 1000,
            callback: this.updateTimer,
            callbackScope: this,
            loop: true
        });
        
        // Initialize game-specific elements
        this.initializeGame();
        
        // Back button
        const backBtn = this.add.text(400, 550, 'â† Back to Course', {
            fontSize: '18px',
            fontFamily: 'Arial',
            color: '#ffffff',
            backgroundColor: '#7b3fe8',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();
        
        backBtn.on('pointerdown', () => {
            this.scene.stop();
            if (window.returnToCourse) window.returnToCourse();
        });
        
        backBtn.on('pointerover', () => backBtn.setStyle({ backgroundColor: '#9b5fff' }));
        backBtn.on('pointerout', () => backBtn.setStyle({ backgroundColor: '#7b3fe8' }));
    }

    initializeGame() {
        // Game-specific initialization
        {GAME_LOGIC}
    }

    update() {
        if (this.gameState !== 'playing') return;
        
        // Game update logic
        {UPDATE_LOGIC}
    }

    updateTimer() {
        if (this.gameState !== 'playing') return;
        
        this.timeLeft--;
        this.timerText.setText(\`Time: \${this.timeLeft}s\`);
        
        if (this.timeLeft <= 0) {
            this.endGame();
        }
    }

    updateScore(points) {
        this.score += points;
        this.scoreText.setText(\`Score: \${this.score}\`);
    }

    endGame() {
        this.gameState = 'ended';
        
        // Show results
        const resultBg = this.add.rectangle(400, 300, 600, 400, 0x000000, 0.9);
        
        this.add.text(400, 200, 'Game Complete!', {
            fontSize: '36px',
            fontFamily: 'Arial',
            color: '#00ff00',
            fontStyle: 'bold'
        }).setOrigin(0.5);
        
        this.add.text(400, 270, \`Final Score: \${this.score}\`, {
            fontSize: '28px',
            fontFamily: 'Arial',
            color: '#ffffff'
        }).setOrigin(0.5);
        
        // Performance feedback
        let feedback = '';
        if (this.score >= 80) feedback = 'ðŸŒŸ Excellent! You mastered this concept!';
        else if (this.score >= 60) feedback = 'ðŸ‘ Good job! Keep practicing!';
        else if (this.score >= 40) feedback = 'ðŸ“š Not bad! Review the concepts again.';
        else feedback = 'ðŸ’ª Keep trying! Practice makes perfect!';
        
        this.add.text(400, 330, feedback, {
            fontSize: '20px',
            fontFamily: 'Arial',
            color: '#ffaa00',
            align: 'center',
            wordWrap: { width: 500 }
        }).setOrigin(0.5);
        
        // Restart button
        const restartBtn = this.add.text(300, 400, 'ðŸ”„ Restart', {
            fontSize: '20px',
            fontFamily: 'Arial',
            color: '#ffffff',
            backgroundColor: '#4CAF50',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();
        
        restartBtn.on('pointerdown', () => {
            this.scene.restart();
        });
        
        // Continue button
        const continueBtn = this.add.text(500, 400, 'âž¡ï¸ Continue', {
            fontSize: '20px',
            fontFamily: 'Arial',
            color: '#ffffff',
            backgroundColor: '#7b3fe8',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();
        
        continueBtn.on('pointerdown', () => {
            this.scene.stop();
            if (window.returnToCourse) window.returnToCourse(this.score);
        });
        
        // Save score
        if (window.saveGameScore) {
            window.saveGameScore('{SCENE_KEY}', this.score);
        }
    }
}

// Register the game scene
if (typeof window !== 'undefined') {
    window.{CLASS_NAME} = {CLASS_NAME};
}
`;
    }

    /**
     * Generate game file for a specific topic
     */
    generateGameFile(subject, topicName, gameDescription, gameLogic = '') {
        const className = this.toClassName(topicName);
        const sceneKey = this.toSceneKey(subject, topicName);
        const gameTitle = `${topicName} Challenge`;
        const instructions = gameDescription || `Master ${topicName} through interactive gameplay!`;
        
        // Generate default game logic if not provided
        const defaultGameLogic = this.generateDefaultGameLogic(subject, topicName);
        const finalGameLogic = gameLogic || defaultGameLogic;
        
        let gameCode = this.baseGameTemplate
            .replace(/{GAME_NAME}/g, topicName)
            .replace(/{CLASS_NAME}/g, className)
            .replace(/{SCENE_KEY}/g, sceneKey)
            .replace(/{GAME_TITLE}/g, gameTitle)
            .replace(/{INSTRUCTIONS}/g, instructions)
            .replace(/{GAME_LOGIC}/g, finalGameLogic)
            .replace(/{UPDATE_LOGIC}/g, '// Update game state');
        
        return gameCode;
    }

    /**
     * Convert topic name to class name
     */
    toClassName(topicName) {
        return topicName
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join('') + 'Game';
    }

    /**
     * Convert to scene key
     */
    toSceneKey(subject, topicName) {
        return `${subject.toLowerCase()}-${topicName.toLowerCase().replace(/\s+/g, '-')}-game`;
    }

    /**
     * Generate default game logic based on subject and topic
     */
    generateDefaultGameLogic(subject, topicName) {
        const subjectLower = subject.toLowerCase();
        const topicLower = topicName.toLowerCase();
        
        // DSA-specific game logic
        if (subjectLower === 'dsa') {
            if (topicLower.includes('stack') || topicLower.includes('queue')) {
                return this.generateStackQueueLogic();
            } else if (topicLower.includes('tree')) {
                return this.generateTreeLogic();
            } else if (topicLower.includes('graph')) {
                return this.generateGraphLogic();
            }
        }
        
        // OS-specific game logic
        if (subjectLower === 'os') {
            if (topicLower.includes('schedul')) {
                return this.generateSchedulingLogic();
            } else if (topicLower.includes('memory')) {
                return this.generateMemoryLogic();
            } else if (topicLower.includes('deadlock')) {
                return this.generateDeadlockLogic();
            }
        }
        
        // Default interactive logic
        return this.generateDefaultInteractiveLogic();
    }

    generateStackQueueLogic() {
        return `
        // Stack/Queue visualization
        this.dataStructure = [];
        this.maxSize = 5;
        
        // Create visual elements
        this.elements = [];
        for (let i = 0; i < this.maxSize; i++) {
            const box = this.add.rectangle(400, 200 + i * 60, 100, 50, 0x3498db);
            const text = this.add.text(400, 200 + i * 60, '', {
                fontSize: '20px',
                color: '#ffffff'
            }).setOrigin(0.5);
            this.elements.push({ box, text });
        }
        
        // Push button
        const pushBtn = this.add.text(250, 450, 'Push', {
            fontSize: '20px',
            backgroundColor: '#27ae60',
            padding: { x: 20, y: 10 }
        }).setInteractive();
        
        pushBtn.on('pointerdown', () => {
            if (this.dataStructure.length < this.maxSize) {
                const value = Math.floor(Math.random() * 100);
                this.dataStructure.push(value);
                this.updateVisualization();
                this.updateScore(10);
            }
        });
        
        // Pop button
        const popBtn = this.add.text(550, 450, 'Pop', {
            fontSize: '20px',
            backgroundColor: '#e74c3c',
            padding: { x: 20, y: 10 }
        }).setInteractive();
        
        popBtn.on('pointerdown', () => {
            if (this.dataStructure.length > 0) {
                this.dataStructure.pop();
                this.updateVisualization();
                this.updateScore(10);
            }
        });
        `;
    }

    generateTreeLogic() {
        return `
        // Binary tree visualization
        this.treeNodes = [];
        this.createTreeNode(400, 150, 50);
        
        // Add node button
        const addBtn = this.add.text(400, 450, 'Add Node', {
            fontSize: '20px',
            backgroundColor: '#27ae60',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();
        
        addBtn.on('pointerdown', () => {
            const value = Math.floor(Math.random() * 100);
            this.addTreeNode(value);
            this.updateScore(15);
        });
        `;
    }

    generateGraphLogic() {
        return `
        // Graph visualization
        this.vertices = [];
        this.edges = [];
        
        // Create sample vertices
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const x = 400 + Math.cos(angle) * 150;
            const y = 300 + Math.sin(angle) * 150;
            this.createVertex(x, y, i);
        }
        
        // Add edge button
        const addEdgeBtn = this.add.text(400, 500, 'Add Edge', {
            fontSize: '20px',
            backgroundColor: '#3498db',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();
        
        addEdgeBtn.on('pointerdown', () => {
            this.addRandomEdge();
            this.updateScore(20);
        });
        `;
    }

    generateSchedulingLogic() {
        return `
        // Process scheduling simulation
        this.processes = [];
        this.currentProcess = null;
        
        // Create process queue
        for (let i = 0; i < 3; i++) {
            this.createProcess(i);
        }
        
        // Schedule button
        const scheduleBtn = this.add.text(400, 450, 'Schedule Next', {
            fontSize: '20px',
            backgroundColor: '#9b59b6',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();
        
        scheduleBtn.on('pointerdown', () => {
            this.scheduleNextProcess();
            this.updateScore(15);
        });
        `;
    }

    generateMemoryLogic() {
        return `
        // Memory allocation simulation
        this.memoryBlocks = [];
        this.allocations = [];
        
        // Create memory blocks
        for (let i = 0; i < 5; i++) {
            const block = {
                x: 150 + i * 120,
                y: 250,
                size: Math.floor(Math.random() * 50) + 30,
                allocated: false
            };
            this.memoryBlocks.push(block);
            this.drawMemoryBlock(block);
        }
        
        // Allocate button
        const allocateBtn = this.add.text(400, 450, 'Allocate Memory', {
            fontSize: '20px',
            backgroundColor: '#e67e22',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();
        
        allocateBtn.on('pointerdown', () => {
            this.allocateMemory();
            this.updateScore(12);
        });
        `;
    }

    generateDeadlockLogic() {
        return `
        // Deadlock detection simulation
        this.resources = [];
        this.processResources = [];
        
        // Create resources
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const x = 400 + Math.cos(angle) * 120;
            const y = 300 + Math.sin(angle) * 120;
            this.createResource(x, y, i);
        }
        
        // Check deadlock button
        const checkBtn = this.add.text(400, 500, 'Check Deadlock', {
            fontSize: '20px',
            backgroundColor: '#c0392b',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();
        
        checkBtn.on('pointerdown', () => {
            this.checkDeadlock();
            this.updateScore(25);
        });
        `;
    }

    generateDefaultInteractiveLogic() {
        return `
        // Interactive challenge
        this.challenges = [];
        this.currentChallenge = 0;
        
        // Create challenge display
        this.challengeText = this.add.text(400, 250, 'Click to start challenge!', {
            fontSize: '24px',
            color: '#ffffff',
            align: 'center',
            wordWrap: { width: 600 }
        }).setOrigin(0.5);
        
        // Answer buttons
        const options = ['Option A', 'Option B', 'Option C', 'Option D'];
        this.answerButtons = [];
        
        options.forEach((option, index) => {
            const btn = this.add.text(400, 320 + index * 50, option, {
                fontSize: '18px',
                backgroundColor: '#34495e',
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive();
            
            btn.on('pointerdown', () => {
                this.checkAnswer(index);
            });
            
            this.answerButtons.push(btn);
        });
        `;
    }

    /**
     * Save game file to disk
     */
    saveGameFile(subject, topicName, gameCode) {
        const fileName = this.toSceneKey(subject, topicName) + '.js';
        const filePath = `games/${subject.toLowerCase()}/${fileName}`;
        
        return {
            path: filePath,
            code: gameCode,
            fileName: fileName
        };
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = GameTemplateGenerator;
} else {
    window.GameTemplateGenerator = GameTemplateGenerator;
}
